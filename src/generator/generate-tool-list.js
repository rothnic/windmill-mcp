#!/usr/bin/env node

/**
 * Generate Tool List Documentation
 *
 * This script generates a markdown document listing all tools
 * generated from the Windmill OpenAPI specification.
 */

import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
import { categorizeTool as categorizeToolPattern } from "../utils/tool-categories.js";

// Load configuration
const configPath = path.join(__dirname, "config.json");
let config;
try {
  const configData = await fs.readFile(configPath, "utf-8");
  config = JSON.parse(configData);
} catch (error) {
  console.error("Error loading config:", error.message);
  process.exit(1);
}

const CACHE_PATH = path.resolve(
  __dirname,
  "..",
  "..",
  config.openapi.localCache,
);
const OUTPUT_PATH = path.resolve(
  __dirname,
  "..",
  "..",
  "docs/generated-tools.md",
);

/**
 * Group tools by category using regex patterns
 */
function categorizeTool(operationId) {
  return categorizeToolPattern(operationId);
}

/**
 * Main function
 */
async function main() {
  console.log("ðŸ” Generating tool list documentation...");

  // Read OpenAPI spec
  let spec;
  try {
    const specData = await fs.readFile(CACHE_PATH, "utf-8");
    spec = JSON.parse(specData);
  } catch (error) {
    console.error("Error reading OpenAPI spec:", error.message);
    process.exit(1);
  }

  // Extract tools with descriptions
  const tools = {};
  for (const [, pathItem] of Object.entries(spec.paths || {})) {
    for (const [, operation] of Object.entries(pathItem)) {
      if (operation && operation.operationId) {
        const category = categorizeTool(operation.operationId);
        if (!tools[category]) {
          tools[category] = [];
        }
        tools[category].push({
          operationId: operation.operationId,
          description:
            operation.summary ||
            operation.description ||
            "No description available",
        });
      }
    }
  }

  // Sort categories and tools
  const sortedCategories = Object.keys(tools).sort();
  for (const category of sortedCategories) {
    tools[category].sort((a, b) => a.operationId.localeCompare(b.operationId));
  }

  // Generate markdown
  let markdown = `# Windmill API Tools

> **âš ï¸ Auto-generated Document**
>
> This file is automatically generated from the Windmill OpenAPI specification.
> Do not edit this file directly. It will be overwritten during the build process.
>
> Generated on: ${new Date().toISOString()}
> Windmill Version: ${spec.info?.version || "unknown"}

This document lists all available tools generated from the Windmill API OpenAPI specification.

`;

  for (const category of sortedCategories) {
    markdown += `## ${category}\n\n`;
    for (const tool of tools[category]) {
      markdown += `### \`${tool.operationId}\`\n\n${tool.description}\n\n`;
    }
    markdown += `\n`;
  }

  markdown += `---

Total tools: ${Object.values(tools).reduce((sum, arr) => sum + arr.length, 0)}

## Tool to Agent Mapping Guide

This document categorizes all Windmill API tools by functional area. Each category maps to specific OpenCode agents:

- **job:** â†’ job-specialist
- **user:** â†’ user-specialist  
- **workspace:** â†’ workspace-specialist
- **script:** â†’ script-specialist
- **flow:** â†’ flow-specialist
- **resource:** â†’ resource-specialist
- **variable:** â†’ storage-specialist
- **schedule:** â†’ trigger-specialist
- **trigger:** â†’ trigger-specialist
- **app:** â†’ app-specialist
- **folder:** â†’ workspace-specialist
- **group:** â†’ user-specialist
- **storage:** â†’ storage-specialist
- **integration:** â†’ integration-specialist
- **audit:** â†’ audit-specialist
- **settings:** â†’ system-specialist
- **system:** â†’ system-specialist
- **capture:** â†’ system-specialist
- **input:** â†’ system-specialist
- **draft:** â†’ system-specialist
- **template:** â†’ system-specialist
- **tutorial:** â†’ system-specialist
- **misc:** â†’ Review category - assign to most relevant specialist

Use this reference when routing tool requests to the appropriate agent.
`;

  // Write output
  try {
    await fs.mkdir(path.dirname(OUTPUT_PATH), { recursive: true });
    await fs.writeFile(OUTPUT_PATH, markdown, "utf-8");
    console.log(`âœ… Tool list generated: ${OUTPUT_PATH}`);
  } catch (error) {
    console.error("Error writing output:", error.message);
    process.exit(1);
  }
}

// Run main function
main().catch((error) => {
  console.error("Unexpected error:", error);
  process.exit(1);
});
